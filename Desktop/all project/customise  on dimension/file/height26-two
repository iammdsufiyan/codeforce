<style>
  .hwp-input-group {
    position: relative;
    margin-bottom: 1rem;
  }
  .hwp-input-group input[disabled] {
    background-color: #f1f1f1;
    cursor: not-allowed;
    border-style: solid;
  }
  .hwp-lock-icon {
    position: absolute;
    top: 50%;
    right: 12px;
    transform: translateY(-50%);
    pointer-events: none;
    display: none;
    width: 16px;
    height: 16px;
  }
  .hwp-input-group input:disabled ~ .hwp-lock-icon {
    display: block;
  }
  .image-uploader {
    border: 2px dashed #90a4ae;
    padding: 2rem;
    text-align: center;
    margin-bottom: 1rem;
    position: relative;
    background-color: #e3f2fd;
    color: #0d47a1;
  }
  .image-uploader:hover {
    border-color: #999;
  }
  .image-uploader input[type="file"] {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
  }
  .image-preview {
    margin-top: 1rem;
    border: 1px solid #ddd;
  }
  #preview-canvas-{{ block.id }} {
    max-width: 100%;
    height: auto;
    display: block;
  }
</style>

{%- liquid
  assign hwp_settings = shop.metafields.custom.height_width_settings.value
  assign price_rules = hwp_settings.priceRules | default: '[]'
  assign is_width_locked = false
  if hwp_settings.lockWidth == true or hwp_settings.lockWidth == 'true' or block.settings.lock_width
    assign is_width_locked = true
  endif

  assign is_height_locked = true
-%}

<div class="height-width-picker">
  <div class="image-uploader">
    <input type="file" id="image-upload-{{ block.id }}" accept="image/*">
    <label for="image-upload-{{ block.id }}">
      <strong>Drag & drop or click to upload your image</strong>
    </label>
  </div>

  <div class="image-preview">
    <canvas id="preview-canvas-{{ block.id }}"></canvas>
  </div>

  <div class="hwp-input-group">
    <label for="width-{{ block.id }}">Width (inches)</label>
    <input
      type="number"
      id="width-{{ block.id }}"
      name="properties[Width]"
      value="{{ hwp_settings.defaultWidth | default: block.settings.default_width | default: 22 }}"
      {% if is_width_locked %}disabled{% endif %}
    >
    <svg class="hwp-lock-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
      <path fill-rule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clip-rule="evenodd" />
    </svg>
  </div>

  <div class="hwp-input-group">
    <label for="height-{{ block.id }}">Height (feet)</label>
    <input
      type="number"
      id="height-{{ block.id }}"
      name="properties[Height]"
      value="{{ hwp_settings.priceRules[0].height | default: block.settings.default_height | default: 2 }}"
      disabled
    >
     <svg class="hwp-lock-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
      <path fill-rule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clip-rule="evenodd" />
    </svg>
  </div>

  <div class="price-display">
    <strong>Price:</strong> <span id="calculated-price-{{ block.id }}">$0.00</span>
  </div>
</div>

<script>
  const priceRules = {{ shop.metafields.custom.height_width_settings.value.priceRules | json }};

  document.addEventListener('DOMContentLoaded', function() {
    const blockId = '{{ block.id }}';
    const imageUpload = document.getElementById(`image-upload-${blockId}`);
    const canvas = document.getElementById(`preview-canvas-${blockId}`);
    const ctx = canvas.getContext('2d');
    const widthInput = document.getElementById(`width-${blockId}`);
    const heightInput = document.getElementById(`height-${blockId}`);
    const priceDisplay = document.getElementById(`calculated-price-${blockId}`);

    const fixedWidthInches = parseFloat(widthInput.value);
    const dpi = 300;

    // Allowed height slabs in feet
    const heightSlabsInches = priceRules.map(rule => {
      if (rule.unit === 'ft') {
        return parseFloat(rule.height) * 12;
      }
      return parseFloat(rule.height);
    });

    imageUpload.addEventListener('change', handleImageUpload);

    // Initial price update
    updatePrice(parseFloat(heightInput.value));

    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          processImage(img);
        }
        img.src = e.target.result;
      }
      reader.readAsDataURL(file);
    }

    function processImage(img) {
      const aspectRatio = img.width / img.height;
      const scaledHeightInches = fixedWidthInches / aspectRatio;

      let requiredHeightInches = 12; // Default to 1ft
      for (const slabInches of heightSlabsInches) {
        if (scaledHeightInches <= slabInches) {
          requiredHeightInches = slabInches;
          break;
        }
      }
      
      // If the required height is larger than the largest slab, use the largest slab
      if (heightSlabsInches.length > 0 && scaledHeightInches > heightSlabsInches[heightSlabsInches.length - 1]) {
        requiredHeightInches = heightSlabsInches[heightSlabsInches.length - 1];
      }

      const requiredHeightFeet = requiredHeightInches / 12;
      heightInput.value = requiredHeightFeet.toFixed(2);

      updatePrice(requiredHeightFeet);
      drawPreview(img, fixedWidthInches, requiredHeightInches);
    }

    function updatePrice(heightFeet) {
      try {
        const heightInches = heightFeet * 12;
        let price = null;

        // Sort rules by height ascending
        const sortedRules = [...priceRules].sort((a, b) => {
          const heightA = a.unit === 'ft' ? parseFloat(a.height) * 12 : parseFloat(a.height);
          const heightB = b.unit === 'ft' ? parseFloat(b.height) * 12 : parseFloat(b.height);
          return heightA - heightB;
        });

        for (const rule of sortedRules) {
          const ruleHeightInches = rule.unit === 'ft' ? parseFloat(rule.height) * 12 : parseFloat(rule.height);
          if (heightInches <= ruleHeightInches) {
            price = rule.price;
            break;
          }
        }

        // If no rule matched, use the last rule's price
        if (price === null && sortedRules.length > 0) {
          price = sortedRules[sortedRules.length - 1].price;
        }

        if (price !== null) {
          priceDisplay.textContent = `$${price}`;
        } else {
          priceDisplay.textContent = 'Price not available';
        }
      } catch (error) {
        console.error('Price calculation error:', error);
        priceDisplay.textContent = 'Price calculation error';
      }
    }

    function drawPreview(img, canvasWidthInches, canvasHeightInches) {
      const previewDpi = 72;
      const aspectRatio = img.width / img.height;
      
      const canvasWidth = canvasWidthInches * previewDpi;
      const scaledHeight = canvasWidth / aspectRatio;

      canvas.width = canvasWidth;
      canvas.height = scaledHeight; // Set canvas height to match scaled image height

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, scaledHeight);
    }
  });
</script>

{% schema %}
{
  "name": "Height and Width Picker",
  "target": "section",
  "settings": [
    {
      "type": "number",
      "id": "default_width",
      "label": "Default width (inches)",
      "default": 22
    },
    {
      "type": "number",
      "id": "default_height",
      "label": "Default height (feet)",
      "default": 2
    },
    {
      "type": "checkbox",
      "id": "lock_width",
      "label": "Lock width",
      "default": true
    },
    {
      "type": "checkbox",
      "id": "lock_height",
      "label": "Lock height",
      "default": false
    },
    {
      "type": "url",
      "id": "image_url",
      "label": "Image URL"
    }
  ]
}
{% endschema %}